\label{SIP:chapter}
% \section{Introduction and Related Work}  \label{SIP:sec:intro}

In Chapter~\ref{GASP:chapter} we considered the setting where an event organizer is to assign agents to multiple activities that take place concurrently. In this chapter, we consider a slightly different setting in which there is only one activity -- and thus the organizer is to choose a subset of agents to be ``invited'' to participate in the activity, while agents may exhibit friend or enemy relationships. 
On the one hand, this is a special case of the Group Activity Selection Problem in that there is only one activity. On the other hand, it is a generalization of this specical case in that agents now have non-anonymous preferences -- they do not only care about the number of participants in the activity, but they also care about who those participants are.

Let us consider a concrete example to understand the setting. Suppose that  an event organizer trying to convene an event -- for example, a fundraiser. We assume that the time and venue for the event are fixed,
and that the only remaining decision for the organizer to make is whom
to invite among a set of agents.
An \emph{invitation} is simply defined to be a subset of agents.
The goal of the organizer is to maximize attendance (for example, 
in order to maximize donations), but the potential invitees have 
their own preferences over how many attendees there should be at the event 
and possibly also who the potential attendees should be.
For example, a given donor may not want to attend if too few attendees 
show up, but she may not want the event to be overly crowded. 
Another donor may want to attend the event only
if her friends attend and her business competitor does not.

Clearly, this can be viewed as an instance of the Group Activity Selection Problem (\GASP) with the exception that agents have non-anonymous preferences. 
We call this the Stable Invitations Problem (\SIP), in which each agent 
can specify a set of friends and a set of enemies (in addition to her preference over sizes as in \GASP).
An agent is willing to attend only if all of her friends attend, none of her enemies attends, and  the number of attendees is acceptable to her. 

Not surprisingly, complexity of \SIPs depends highly on the cardinality of friend-sets and enemy-sets, as friends-and-enemies relationship introduces combinatoric complexity in the problem of finding a good solution. 
In this chapter we provide a complete analysis of complexity results on \SIPs; we consider individual rationality (IR) and Nash stability as we did for \GASP, and we also consider both asymmetric and symmetric friends-and-enemmies relation. 

From the work by Darmann et al.~\cite{GASP12WINE}, we know that if all agents have anonymous preferences, then \SIPs can be solved in polynomial time -- which is equivalent to \GASPs with one activity. Yet, as we shall show, preferences of agents play an important role in complexity of \SIPs under various settings. 


\section{Definitions} \label{SIP:sec:SIP:prelim}

Let us first define the Stable Invitations Problem and related solution concepts. 

\begin{definition}
An instance of the Stable Invitations Problem (\SIP) is given by a set of agents $N = \{a_1, a_2, \dots, a_n\}$, and an {\em approval set} $S_i \subseteq [1,n]$, a {\em friend set} $F_i \subseteq N$, and an {\em enemy set} $E_i \subseteq N$ for each agent $a_i\in N$.
It is interpreted that agent $a_i$ is willing to attend if all friends in $F_i$ attend, no one in $E_i$ attends, and the number of attendees (including $a_i$) is acceptable (i.e., the number is contained in $S_i$).
\end{definition}

\begin{definition} 
An invitation $I$ in \SIPs is a subset of agents.

	We say that an invitation $I$ is {\em individually rational} (IR) if for every agent $a_i\in I$, $|I| \in S_i$, $F_i \subseteq I$, and $R_i \cap I = \emptyset$.
	
	We say that an invitation $I$ is {\em (Nash) stable} if it is individually rational, and if for every agent $a_j \not\in I$, $|I_j'| \not\in S_j$, $F_j \not\subseteq I_j'$, or $R_j \cap I_j' \neq \emptyset$ where $I_j' = I \cup \{a_j\}$.
\end{definition}

Individual rationality (IR) requires every invited agent be willing to attend.
Stability further requires those who are not invited be unwilling to participate (without permission of others)
because not all of her friends are attending, some of her enemies are attending, or the number of attendees would be unacceptable. 
We consider the following two problems of finding invitations of size $k$:
\begin{itemize}
	\item $k$-IR-Invitation: $\exists$ IR invitation of size $k$?
	\item $k$-Stable-Invitation: $\exists$ stable invitation of size $k$?
\end{itemize}

We first consider restrictions on inputs by limiting the size of largest friend-sets and enemy-sets, respectively. 
For integer constants $\alpha$ and $\beta$, if an instance of \SIPs satisfies $|F_i| \leq \alpha$ and $|E_i| \leq \beta$ for all $a_i\in N$, we call it an $(\alpha,\beta)$-instance of \SIP. 
Lee and Shoham~\cite{LEE15AAAI} showed that \SIPs can be solved in polytime only if $\alpha$ and $\beta$ are small enough, but the problems are NP-hard in general. We will consider the same restrictions in this work, and provide our complete analysis of parameterized complexity of \SIP.

In addition to these restrictions, we consider the special case where agents have symmetric social relationships.
\begin{definition} \label{SIP:def:symmetric_social}
	Given an instance of \SIP, we say that agents have {\em symmetric social relationships} if $a_j\in F_i$ if and only if $a_i\in F_j$ and $a_l \in E_i$ if and only if $a_i \in E_l$ for every $a_i$. 
\end{definition}

Theorem~\ref{SIP:thm:nphard} summarizes the most relevant results of Darmann et al.~\cite{GASP12WINE} and Lee and Shoham~\cite{LEE15AAAI} on complexity of \SIPs.\footnote{
Darmann et al.~\cite{GASP12WINE} showed easiness when $\alpha=\beta=0$, while Lee and Shoham~\cite{LEE15AAAI} proved easiness and hardness in all other cases.}
\begin{theorem} \label{SIP:thm:nphard} [\cite{LEE15AAAI,GASP12WINE}]
	$k$-IR-Invitation and $k$-Stable-Invitation can be solved in polynomial time if $(\max_{a_i \in N} |F_i|) + (\max_{a_i \in N} |E_i|) \leq 1$ (i.e., $\alpha + \beta \leq 1$). In other cases, both problems are NP-hard.
\end{theorem}
Note that $k$-IR-Invitation and $k$-Stable-Invitation are of the same classical complexity, even though stability is a stronger solution concept. Under parameterization, however, these two problems are contained in different complexity classes in the W-hierarchy (see Table~\ref{SIP:tbl:summary}).
In what follows, we show that the parameterized complexity of these problems varies with different solution concepts and under different restrictions on inputs to \SIP.





\section{Parameterized Complexity} \label{SIP:sec:results}

 \begin{table*}[t!]
	 \small
 	\centering
 \begin{tabular}{|l|*{4}{c|}|*{4}{c|}}\hline
 \multirow{2}*{} & \multicolumn{4}{c||}{$k$-IR-Invitations} & \multicolumn{4}{c|}{$k$-Stable-Invitations} \\ \cline{2-9}
  & $\beta = 0$ & $\beta = 1$ & $2 \leq \beta \leq f(k)$ & unbounded $\beta$ & $\beta = 0$ & $\beta = 1$ & $2 \leq \beta \leq f(k)$ & unbounded $\beta$ \\ \hline
 $\alpha = 0$ & P & P & FPT  & W[1]-C & P & P & FPT & W[2]-C \\ \hline
 $\alpha = 1$ & P & FPT  & FPT & W[1]-C & P & W[1]-C & W[1]-C & W[2]-C\\ \hline
 $\alpha \geq 2$ & W[1]-C & W[1]-C & W[1]-C & W[1]-C & W[1]-C & W[1]-C & W[1]-C & W[2]-C \\ \hline
 \end{tabular}
 \caption{\small Complexity of $k$-IR-Invitation and $k$-Stable-Invitation. $f(k)$ can be an arbitrary function of $k$ that only depends on $k$.
 All entries other than ``P'' imply NP-completeness.
  ``W[1]-C'' and ``W[2]-C'' mean W[1]-completeness and W[2]-completeness, respectively. 
Note that P and NP-completeness results were known prior to this work as summarized in Theorem~\ref{SIP:thm:nphard}, but all other results are original. }
 \label{SIP:tbl:summary}
 \end{table*}


In this section, we study parameterized complexity of $k$-IR-Invitation and $k$-Stable-Invitation.
Our main contributions are summarized in Table~\ref{SIP:tbl:summary}. For instance, finding an IR invitation of size $k$ is in FPT when $\alpha = 1$ and $\beta$ is a positive constant (bounded above by some function of $k$), but finding a stable invitation in the same cases is W[1]-complete. 
 

\subsection{$k$-IR-Invitation}

Recall that $k$-IR-Invitation is the problem of finding an IR invitation of size $k$.
When $\alpha + \beta > 1$, the problem is known to be NP-hard (Theorem~\ref{SIP:thm:nphard}). 
We first present easiness results: $k$-IR-Invitation is in W[1] in general, and it is in FPT if $\alpha \leq 1$ and $\beta$ is bounded by some function $f(k)$ of $k$.
We then present hardness results by showing that $k$-IR-Invitation is W[1]-hard when $\alpha \geq 2$ and/or $\beta$ is unbounded.


\begin{theorem} \label{SIP:thm:IR_invitation_W1}
	$k$-IR-Invitation is in W[1].
\end{theorem} 
\begin{proof}
	We reduce $k$-IR-Invitation to the weighted circuit SAT (WCSAT) of constant depth and of weft at most 1. 
	
	Details of the proof can be found in proof of Theorem~\ref{SIP:thm:stable_W2} which appears later in this chapter.
\end{proof}


\begin{theorem} \label{SIP:thm:IR_invitation_FPT}
	$k$-IR-Invitation is in FPT if $\alpha \leq 1$ and $\beta \leq f(k)$ where $f(k)$ can be an arbitrary function of $k$. 
\end{theorem}
\begin{proof}
	Without loss of generality, assume that $k\in S_i$ for all $a_i \in N$.
	Otherwise, we can remove $a_i$ from the input instance as no IR invitation of size $k$ can contain $a_i$. If $a_i$ is removed, and there is some $a_j$ with $a_i \in F_j$, we remove $a_j$ as well for the same reason. We repeat this removal process until no such agent remains (this can be done in linear time).

	Let $\mathcal{A}$ be some polytime algorithm that solves $k$-IR-Invitation if $\alpha \leq 1$ and $\beta = 0$ (it exists due to Theorem~\ref{SIP:thm:nphard}). We will use $\mathcal{A}$ as a sub-routine in our FPT algorithm. Consider any coloring $c$ which colors agents using two colors $\{0,1\}$; let $c(i) \in \{0,1\}$ be the color of agent $a_i$.
	We say that coloring $c$ and IR invitation $I$ of size $k$ are {\em compatible} if the following holds: For every agent $a_i\in I$, $c(i) = 1$ and for every agent $a_j \in \cup_{i: i\in I} E_i$, $c(j) = 0$. 
	Note that coloring $c$ may be compatible with any number of IR invitations of size $k$ (possibly none), and any IR invitation of size $k$ may be compatible with many colorings (but it is compatible with at least one coloring).
	
	Given some arbitrary coloring $c$, we can find an IR invitation of size $k$ that is compatible with $c$ or determine that no compatible IR invitation exists in FPT time as follows.
	First, we re-color every agent $a_i$ with $c(i)=1$ to color $0$ such that $\exists a_j\in F_i$ with $c(j)=0$ or $\exists a_l \in E_i$ with $c(l) = 1$ (order in which we re-color agents does not matter).
	Notice that this process does not re-color any agent $a_i\in I$ if $I$ is compatible with $c$. After the re-coloring step, let $N_1 = \{a_i\in N: c(i) = 1\}$, and we run the algorithm $\mathcal{A}$ on $N_1$ as input. Suppose that $\mathcal{A}$ finds an IR invitation $I$ of size $k$ given $N_1$. $I$ is individually rational because its friend constraints are satisfied (due to correctness of $\mathcal{A}$) and its enemy constraints are satisfied because no agent with color $0$ is included in $N_1$ (enforced by coloring). Now suppose that $\mathcal{A}$ reports that no IR invitation $I$ of size $k$ exists among the agents in $N_1$. Then there is no IR invitation of size $k$ that is compatible with $c$; if such invitation $I' \subseteq N_1$ exists, then $I'$ satisfies the friend constraints (because it is IR) and therefore $\mathcal{A}$ should find it, which is a contradiction. Hence if our algorithm begins with coloring that is compatible with some IR invitation(s), it will find one.

	If we color agents uniformly and independently at random, then the probability of success of our algorithm is at least $1/2^{(k+1)\beta}$ (because, with respect to some fixed IR invitation $I^*$, we must color all agents in $I^*$ as 1 and the union enemies of agents in $I^*$ as 0, to start with compatible coloring). If we run this algorithm $2^{(k+1)\beta}\ln n$ times, the probability of success is at least $1 - 1/n$. Our FPT algorithm's runtime depends on the runtime of $\mathcal{A}$. The algorithm can be de-randomized using a family of $k$-perfect hash functions as shown in the work by Alon et al.~\cite{ColorCoding}.
\end{proof}


\begin{theorem} \label{SIP:thm:IR_invitation_large_beta}
	$k$-IR-Invitation is W[1]-complete if $\beta$ is not bounded above by any function $f(k)$. 
\end{theorem}
\begin{proof}
	We reduce from the $k$-Independent-Set problem which is known to be W[1]-complete. 
	Given an arbitrary graph $G = (V, E)$ and a parameter $k$, we create agents $N = V = \{v_1, v_2, \dots, v_n\}$. 
	For each $v_i$, define $S_{v_i} = \{k\}$, $F_{v_i} = \emptyset$, and $E_{v_i} = \{v_j : (v_i, v_j)\in E\}$ (hence $\beta$ is equal to the max-degree of nodes in $G$). 
	If $I \subset V$ is an independent set of size $k$, then $I$ is an IR invitation in the instance we created: For all $v_i \in I$, we have $|I| = k \in S_{v_i}$, $F_{v_i} = \emptyset \subset I$, and $E_{v_i} \cap I = \emptyset$ because $I$ is an independent set in the original graph.
	Conversely, suppose $I$ is an IR invitation of size $k$ in the instance we created. Then $I$ is an independent set because no two agents in $I$ are enemies of each other, and thus their corresponding nodes in the graph are not neighbors of each others. This reduction proves W[1]-hardness, and W[1]-completenes follows from Theorem~\ref{SIP:thm:IR_invitation_W1}.
\end{proof}

\begin{theorem} \label{SIP:thm:IR_invitation_alpha2}
	$k$-IR-Invitation is W[1]-complete if $\alpha \geq 2$.
\end{theorem}
\begin{proof}	We reduce from the $k$-Clique problem.
	Given an arbitrary graph $G = (V, E)$ and a parameter $k$, we create a set of agents $N$ as follows. 
	For each node $v_i\in V$, we create $k^2$ node-agents that are labeled as $w_{i,x}$ where $x \in [k^2]$. 
	For each node-agent $w_{i,x}$ we define $F_{w_{i,x}} = \{w_{i,x+1}\}$ (where $w_{i,k^2+1}$ is understood as $w_{i,1}$) and $E_{w_{i,x}} = \emptyset$. 
	Note that an IR invitation must include all or none of the $w_{i,x}$'s for each $i$ because of their friend sets.
	Next, for each edge $(v_i, v_j) \in E$, we create an edge-agent $e_{i,j}$ with $F_{e_{i,j}} = \{w_{i,1}, w_{j,1}\}$ and $E_{e_{i,j}} = \emptyset$. 
	Note that if an IR invitation includes $e_{i,j}$, then it must also include all $2k^2$ node-agents of the form $w_{i,x}$ and $w_{j,x}$ with $x\in[k^2]$ (due to friend sets).
	
	Finally, define $k' = k^3 + \binom{k}{2}$ to be the parameter for the $k$-IR-Invitations we created, and define approval sets of all agents to contain $k'$. 
	Clearly the instance we created satisfies $\alpha = 2$ and $\beta = 0$. 
	The number of agents we created is $k^2|V| + |E|$, polynomial in the size of the original instance.
	It remains to show that a clique of size $k$ exists if and only if an IR invitation of size $k' = k^3 + \binom{k}{2}$ exists.

	If $C$ is a clique of size $k$ in the original graph, define $I = \{w_{i, x}: v_i\in C, x\in[k^2]\} \cup \{e_{i,j} : v_i, v_j \in C\}$. Clearly, $|I| = k^3 + \binom{k}{2}$ because $|C| = k$. To see that $I$ is individually rational, every agent in $I$ approves size $k^3 + \binom{k}{2}$, every agent included in $I$ has their friends included in $I$.  

	Conversely, suppose that $I$ is an IR invitation of size $k^3 + \binom{k}{2}$ in the instance we created.
	Let us define $G_i = \{w_{i,x} : x\in [k^2]\}$ to be the set of node-agents corresponding to $v_i$ in the original instance (informally, $G_i$ is a cycle of length $k^2$ representing node $v_i$). Recall that $I$ must contain all node-agents or none in $G_i$ for each $i$ if $I$ is individually rational. If $I$ contains more than $k$ such sets, then $|I| \geq (k+1)k^2 > k^3 + \binom{k}{2}$, and therefore $I$ can contain at most $k$ such sets, which means that $I$ must contain at least $\binom{k}{2}$ edge-agents (because $|I| = k^3 + \binom{k}{2}$). 
	Now suppose that $I$ contains more than $\binom{k}{2}$ edge-agents. Then $I$ must include at least $k+1$ of $G_i$'s because each edge-agent $e_{i,j}$ in $I$ requires both $G_i$ and $G_j$ to be included in $I$, and containing more than $\binom{k}{2}$ edge-agents in $I$ implies that at least $k+1$ sets of node-agents are included in $I$ which we argued leads to a contradiction. That is, $I$ can contain at most $\binom{k}{2}$ edge-agents. Together with the previous argument, this means that $I$ contains exactly $\binom{k}{2}$ edge-agents and exactly $k$ sets of node-agents. Because $e_{i,j} \in I$ implies that there is an edge $(v_i, v_j)$ in the original instance, this implies that a clique of size $k$ exists in the original instance. 

	
	Note that W[1]-completenes follows from Theorem~\ref{SIP:thm:IR_invitation_W1}.
\end{proof}








\subsection{$k$-Stable-Invitation}
 
$k$-IR-Invitation and $k$-Stable-Invitation have the same classical complexity for all values of $\alpha$ and $\beta$, but parameterization indicates that $k$-Stable-Invitation is a more difficult problem than $k$-IR-Invitation.
This is not surprising because a stable invitation requires that everyone (whether invited or not) be satisfied with the invitation.

% thm:stable_W2
\begin{theorem} \label{SIP:thm:stable_W2}
	$k$-Stable-Invitation is in W[2]. When $\beta$ is bounded above by some function $f(k)$, it is in W[1].
\end{theorem}
\begin{proof}
	Assume unbounded $\alpha$ and $\beta$, and let us reduce the $k$-Stable-Invitation problem to the weighted circuit SAT (WCSAT) of constant depth and of weft at most 2. This shows that the problem is in W[2]; along the way, we prove the other statements as well.

	Given an instance of the $k$-Stable-Invitation problem with $n$ agents ($N = \{a_1, a_2, \dots, a_n\}$), we create $n$ input nodes which represent each agent being invited or not; let $x_i$ be the input node for agent $a_i$ ($x_i = 1$ means that agent $a_i$ is included in an invitation). For convenience we also create a node $y_i$ for each $x_i$ where $y_i$ is the NOT gate attached to $x_i$. We create the output AND gate denoted by $x_o$. 
	
	For each agent $a_i$, if $k\not\in S_i$ and/or $|F_i| \geq k$, then agent $i$ cannot be included in a stable invitation of size $k$; for all such $a_i$, we create a path from the node $x_i$ to $y_i$ (recall that $y_i$ simply negates $x_i$) to the output node $x_o$.
	For each agent $a_i$ with $k \in S_i$ and $|F_i| < k$, we wish to ensure that if agent $a_i$ is included, then everyone in $F_i$ is included and no one in $R_i$ is included. For each agent $j\in F_i$, we create a new node $f_{i,j}$ with the OR gate whose input is $y_i$ and $x_j$, and the output node $x_o$ takes $f_{i,j}$ as input. Note that a solution to the WCSAT instance must have $f_{i,j} = 1$ for all $i,j$ (if the node $f_{i,j}$ is created), which holds if and only if $(x_i, x_j) \in \{(0,0), (0,1), (1,1)\}$. This ensures that if $a_i$ is selected, all agents in $F_i$ are also selected. Note that each path containing $f_{i,j}$ to the output node has a constant depth and a weft of $1$ (due to the output node). Similarly, for each $j\in R_i$ with $k\in S_i$ and $|F_i| < k$, we create a new node $r_{i,j}$ with the OR gate whose input is $x_i$ and $y_j$, and the output node $x_o$ takes $r_{i,j}$ as input. 
	So far we have implemented a circuit such that any solution to the WCSAT instance corresponds to an IR invitation of size $k$. Every path from any input node to the output node has constant depth and weft 1 (due to the output node), and this shows that $k$-IR-Invitation is in W[1]. 
	
	To ensure stability in addition to individual rationality, we need to add more gates and paths. 	
	For each agent $a_i$ with $k+1 \in S_i$, if agent $a_i$ is not included in an invitation, then the invitation is stable only if at least one agent in $F_i$ is not included and/or at least one agent in $R_i$ is included.
	Note that if $|F_i| > k$, then every solution to the WCSAT leaves out at least one agent from $F_i$, and therefore agent $a_i$ (even if excluded) would not be willing to join the invitation. Therefore, we only need to ensure stability for those agents with $k+1\in S_i$ and $|F_i| \leq k$. 
	For each such agent $a_i$, let us create a new node $s_i$ with the OR gate whose input consists of all nodes $y_j$ where $j\in F_i$, all nodes $x_j$ where $j \in R_i$, and $x_i$ itself. Note that $s_i = 1$ if $x_i = 1$ (when agent $a_i$ is selected) or if $x_i = 0$ and at least one friend (enemy) of agent $a_i$ is not included (included). Notice that any path containing $s_i$ has a constant depth but a weft of size 2 due to $s_i$ and the output node. This shows that $k$-Stable-Invitation is in W[2].
	
	When $\beta$ is bounded by $f(k)$ (any constant not depending on $n$), we can create a chain of nodes to implement $s_i$. Specifically, instead of having $s_i$ to take $(|F_i| + |R_i| + 1)$ inputs, we create a chain of nodes with the OR gate, each of which takes only two inputs. Although this increases the depth of a path containing these nodes to $(|F_i| + |R_i| + 1)$, the depth is bounded by $(k + f(k) + 1)$ because $|F_i| \leq k$. Therefore, when $\beta$ is bounded, the $k$-Stable-Invitation is in W[1].	
\end{proof}

\begin{theorem} \label{SIP:thm:stable_FPT}
	$k$-Stable-Invitation is in FPT when $\alpha = 0$ and $\beta \leq f(k)$ where $f(k)$ can be an arbitrary function of $k$.
\end{theorem}
\begin{proof}
	The main idea is similar to that of our proof of Theorem~\ref{SIP:thm:IR_invitation_FPT}. 

	Consider any coloring $c$ which colors agents using two colors $\{0, 1\}$; let $c(i)\in \{0,1\}$ be the color of agent $a_i$. Let $I$ be a stable invitation of size $k$. We say that $c$ and $I$ are {\em compatible} if the following holds: For every agent $a_i\in I$, $c(i) = 1$ and for every agent $a_j\in \cup_{i: a_i\in I} R_i$, $c(j) = 0$; other agents can be of any color. 
	Given an arbitrary coloring $c$, we can find a stable invitation of size $k$ that is compatible with $c$ or determine that no compatible invitation exists in FPT time. 

	Given $c$, we first re-color some of the agents if necessary as follows. If there is some agent $a_i$ with $c(i) = 1$ and $k\not\in S_i$, then we re-color agent $i$ as $c(i) = 0$ as no stable invitation can include $i$. If there is some agent $i$ with $c(i) = 1$ and $\exists j\in R_i$ such that $c(j) = 1$, then we re-color agent $i$ as $c(i) = 0$ as no compatible invitation $I$ can include $i$ in it. We repeat these re-coloring steps until no such agents exist (which happens at most $O(|N|)$ times). 
	
	After all re-coloring steps are completed, we partition the set of agents into four subsets as follows. Define $X_d = \{a_i\in N : c(i) = d \land k+1\in S_i\}$ and $Y_d = \{a_i\in N : c(i) = d \land k+1\not\in S_i\}$ where $d\in \{1, 2\}$.
	For any $I$ compatible with $c$, it must hold that $X_1 \subseteq I$ (because $I$ is stable) and that $I \subseteq X_1 \cup Y_1$ (because $c$ and $I$ are compatible). 
	Therefore if $|X_1| > k$ or $|X_1| + |Y_1| < k$, then we conclude that no stable invitation of size $k$ is compatible with $c$ and terminate. Because $X_1 \subseteq I$ for all $I\in \mathcal{I}_c$, let us assume that $X_1 = \emptyset$ without loss of generality.
	
	Then, $I \subseteq Y_1$ for every stable invitation $I$ that is compatible with $c$. We cannot do a naive exhaustive search on $Y_1$ to find compatible $I$ because the search space can be as large as $O(n^k)$. Yet we can reduce the search space to $O(\beta^k)$. Let $I'$ be any subset of $Y_1$ of size $k$; $I'$ is individually rational due to the proper coloring constraint. Therefore its stability only depends on the existence of some agent $a_i \in X_0$ such that $R_i \cap I' = \emptyset$. Let $J = \emptyset$, and let us construct an invitation of size $k$. If there is some agent $a_i\in X_0$ such that $R_i \cap J = \emptyset$, then we try adding one agent from $R_i \cap Y_1$ to $J$, thereby increasing the size of $J$ by one. We repeat this process in an exhaustive manner until $J$ contains $k$ agents or there is no such agent $i \in X_0$ such that $R_i \cap J = \emptyset$. If the former occurs, we check whether $J$ is a stable invitation of size $k$ in poly-time; if $J$ is stable, then we output $J$, otherwise we continue exhaustive search. If the latter occurs, we can choose an arbitrary invitation $I$ with $J\subseteq I \subseteq Y_1$ because any such $I$ is guaranteed to be stable. Note that the search space is $O(\beta^k)$ because we choose up to $k$ agents (as $|J| \leq k$ at all times) and at each step we have at most $\beta$ agnets to choose from (i.e., $|R_i \cap J| \leq |R_i| \leq \beta$). 

	Therefore, this algorithm finds a stable invitation of size $k$ if it is given a proper coloring of any stable invitation of size $k$ in time $O(\beta^k n^O(1))$. We can de-randomize this algorithm by de-randomizing the coloring step (for instance, one can use $k$-perfect family of hash functions as in the work by \cite{ColorCoding}).
\end{proof}




\begin{theorem} \label{SIP:thm:stable_W1hard_alpha1_beta1}
	$k$-Stable-Invitation is W[1]-complete if $\alpha,\beta \geq 1$ and $\beta$ is bounded above by some function $f(k)$.
\end{theorem}
\begin{proof}
	We reduce from the $k$-Clique problem to show W[1]-hardness. 
	Let $G = (V, E)$ be an arbitrary graph for the $k$-Clique problem with parameter $k$. 
	Let us define $k' = 2(k^3 + \binom{k}{2})$ which is the parameter for $k$-Stable-Invitation. 
	For each node $v_i \in V$, we first create a group of $2k^2$ node-agents (call them $G_i$) such that $G_i=\{w_{i,x}: x \in [2k^2]\}$, and define $F_{w_{i,x}} = \{w_{i,x+1}\}$ (where $w_{i,2k^2+1}$ is understood as $w_{i,1}$) and $S_{w_{i,x}} = \{k'\}$.
	 For each edge $(v_i, v_j) \in E$, we create four edge-agents $e_{i,j}, e'_{i,j}, f_{i,j}$, and $f'_{i,j}$.
	 Define $F_{e_{i,j}} = \{w_{i,1}\}$, $F_{e'_{i,j}} = \{w_{j,1}\}$, and $S_{e_{i,j}} = S_{e'_{i,j}} = \{k'\}$. 
	 Define $F_{f_{i,j}} = \{e_{i,j}\}$, $E_{f_{i,j}} = \{e'_{i,j}\}$, and $S_{f_{i,j}} = \{k'+1\}$.
	 Define $F_{f'_{i,j}} = \{e'_{i,j}\}$, $E_{f'_{i,j}} = \{e_{i,j}\}$, and $S_{f'_{i,j}} = \{k'+1\}$.
	 We have created $2k^2n$ node-agents and $4|E|$ edge-agents, whose size is polynomial in $n,k$, and each agent we created has at most one friend and at most one enemy (thereby satisfying $\alpha=\beta=1$). 

	 Suppose $C$ is a clique of size $k$. Without loss of generality, suppose $C = \{v_1, v_2, \dots, v_k\}$, and define $I = (\cup_{i=1}^{k} G_i)\cup \{e_{i,j}, e'_{i,j}: 1 \leq i < j \leq k\}$. Note that $|I| = 2k^3 + 2 \binom{k}{2} = k'$, and we claim that $I$ is a stable invitation. It is clear that $I$ is individually rational, as each agent in $I$ approves the size $k'$ and her friends are all included in $I$. To see why $I$ is stable, first notice that any node-agent $v_j \not\in I$ and any edge-agents $e_{i,j}, e'_{i,j}\not\in I$ does not approve the size $k+1$. Now consider any edge-agent $f_{i,j}$. Since $I$ contains both or neither of $e_{i,j}$ and $e'_{i,j}$, $f_{i,j}$ does not wish to join $I$ because $f_{i,j}$ has one of them in friend-set and the other in enemy-set. Similarly, no edge-agent $f'_{i,j}$ wishes to join $I$. Therefore, $I$ is a stable invitation of size $k'$. 
	 
	 Conversely, suppose that $I$ is a stable invitation of size $k'$. Because $I$ must contain all or none of $G_i$ for each $i$, $I$ can contain at most $k$ such groups of node-agents (otherwise, if it contains more than $k$ such groups, the size of the invitation would exceed $k'$). Because $I$ is stable, it cannot contain any of the edge-agents $f_{i,j}$ or $f'_{i,j}$ as they do not approve the size $k'$. Finally, for every pair of edge-agents $e_{i,j}$ and $e'_{i,j}$, $I$ must contain both or neither of them; if only one of them is included in $I$, then either $f_{i,j}$ or $f'_{i,j}$ would wish to join $I$ which contradicts the stability of $I$. Therefore, because we earlier argued that $I$ can contain at most $k$ groups of node-agents, we conclude that $I$ must contain at least $2\binom{k}{2}$ edge-agents of the form $e_{i,j}$ and $e'_{i,j}$. Furthermore, because $e_{i,j},e'_{i,j} \in I$ implies that $G_i\subset I$ and $G_j\subset I$, if $I$ contains more than $2\binom{k}{2}$ edge-agents, it must also contain at least $k+1$ groups of node-agents (which we argued earlier leads to a contradiction). In summary, if $I$ is a stable invitation of size $k'$, it must contain exactly $k$ groups of node-agents (without loss of generality, assume that $I$ contains $G_1, G_2, \dots, G_k$) and exactly $2\binom{k}{2}$ edge-agents that are precisely $\{e_{i,j}, e'_{i,j}: 1\leq i<j\leq k\}$. Then, $C = \{v_1, v_2, \dots, v_k\}$ is a clique in the original instance because there exists an edge between $v_i$ and $v_j$ for every pair $v_i,v_j\in C$ (the fact that edge-agents $e_{i,j}$ exist implies this). 
	
	This shows W[1]-hardness, and W[1]-completenes follows from Theorem~\ref{SIP:thm:stable_W2}. 

\end{proof}


\begin{theorem} \label{SIP:thm:stable_W1hard_alpha2_beta0}
	$k$-Stable-Invitation is W[1]-complete if $\alpha \geq 2$ and $\beta$ is bounded above by some function $f(k)$.
\end{theorem}
\begin{proof}
	We reduce from the $k$-Independent-Set problem to show W[1]-hardness. 
	Let $G = (V, E)$ be an arbitrary instance of the $k$-Independent-Set problem with parameter $k$. 
	For each node $v\in V$ we create a node-agent $v$ with approval set $S_v = \{k\}$ and friend set $F_v = \emptyset$.
	For each edge $(v, w) \in E$ we create an edge-agent $e_{v,w}$ with friend set $F_{e_{v,w}} = \{v, w\}$ and approval set $S_{e_{v,w}} = \{k+1\}$.
	
	Suppose $S \subseteq V$ is an independent set of size $k$ and let $I = S$. $I$ is individually rational as for every node-agent $v\in I$, $|I| = k \in S_v$ and $F_v \subseteq I$. To see why $I$ is stable, for every node-agent $w \not\in I$, $k+1 \not\in S_w$. For every edge-agent $e_{v,w}$, we know that $v\not\in I$ or $w\not\in I$ because if $v,w\in I$ then $v,w\in S$ and $(v,w)\in E$, which contradicts the fact that $S$ is an independent set (note that the edge-agent $e_{v,w}$ is created only if $(v,w)\in E$). Therefore $I$ is a stable invitation of size $k$.
	
	Conversely, suppose that $I$ is a stable invitation of size $k$. Then $I$ cannot contain any edge-agent because every edge-agent only approves the size $k+1$. Let $S = I$ and we claim that $S$ is an independent set. If there is a pair of nodes $v,w \in S$ with $(v, w)\in E$, then there must exist an edge-agent $e_{v,w}$. However, $F_{e_{v,w}} = \{v, w\}$ and $e_{v,w}\not\in I$, which implies that $I$ is not stable. This is a contradiction, and therefore $S$ is an independent set of size $k$. 

	This shows W[1]-hardness, and W[1]-completenes follows from Theorem~\ref{SIP:thm:stable_W2}.
\end{proof}


\begin{theorem} \label{SIP:thm:stable_W2hard_beta}
	$k$-Stable-Invitation is W[2]-complete if $\beta$ is not bounded above by any function of $k$.
\end{theorem}
\begin{proof}
	We reduce from the $k$-Dominating-Set problem which is known to be W[2]-hard.
	Given an arbitrary graph $G = (V, E)$ and a parameter $k$, we create $2n$ node-agents by creating $x_i$ and $y_i$ for each $v_i\in V$. We define their approval sets and enemy sets as follows: $S_{x_i} = \{k\}$ and $E_{x_i} = \emptyset$ for all $x_i$ while $S_{y_i} = \{k+1\}$ and $E_{y_i} = \{x_i\} \cup \{x_j : (v_i, v_j)\in E\}$ for all $y_i$. Note that a stable invitation cannot contain any of $y_i$'s because of their approval sets.
	
	Let $D$ be a dominating set of size $k$ in the original instance, and let $I = \{x_i : v_i \in D\}$. 
	We claim that $I$ is a stable invitation of size $k$. 
	For every node-agent $x_i\in I$, $|I| = k \in S_{x_i}$ and $E_{v_i} \cap I = \emptyset$, and thus $I$ is individually rational. 
	For every node-agent $x_j \not\in I$, $k+1 \not\in S_{x_j}$, and thus $x_j$ has no incentive to join $I$. 
	For every node-agent $y_i$, either $x_i\in I$ or there is some $x_j\in I$ such that $x_j \in E_{y_i}$ because $D$ is a dominating set; that is, if $v_i \not\in D$, then there exists some $v_j\in D$ where $(v_i, v_j) \in E$, which implies that $\exists x_j \in E_{y_i} \cap I$ if $y_i\not\in I$. 
	
	Conversely, suppose that there exists a stable invitation $I$ of size $k$. 
	Clearly $I$ can only contains node-agents of the form $x_i$'s (due to approval sets of $y_i$'s), and we claim that $D = \{v_i : x_i \in I\}$ is a dominating set. 
	Pick any node-agent $x_i\not \in I$. Since $I$ is stable and $x_i\not\in I$, we know that there exists some node-agent $x_j\in I$ such that $x_j\in E_{y_i}$. This implies that $(v_i, v_j) \in E$, and therefore $D$ is a dominating set. 
	
	This shows W[2]-hardness, and W[2]-completenes follows from Theorem~\ref{SIP:thm:stable_W2}.
\end{proof}







\section{Symmetric Social Relationship} \label{SIP:sec:symm}

 \begin{table*}[t!]
	 \small
 	\centering
 \begin{tabular}{|l|*{5}{c|}|*{5}{c|}}\hline
 \multirow{2}*{} & \multicolumn{5}{c||}{$k$-IR-Invitations (symmetric social relationships)} & \multicolumn{5}{c|}{$k$-Stable-Invitations (symmetric social relationships)} \\ \cline{2-11}
  & $\beta = 0$ & $\beta = 1$& $\beta=2$ & $3 \leq \beta \leq f(k)$ & unbounded $\beta$ & $\beta = 0$ & $\beta = 1$ & $\beta=2$ & $3 \leq \beta \leq f(k)$ & unbounded $\beta$  \\ \hline
 $\alpha = 0$ & P & P & P & FPT & W[1]-C & P & P & P & FPT & W[2]-C \\ \hline
 $\alpha = 1$ & P & P & FPT & FPT & W[1]-C & P & P & FPT & FPT & W[2]-C \\ \hline
 $\alpha \geq 2$ & P & FPT & FPT & FPT & W[1]-C & P & FPT & FPT & FPT & W[2]-C \\ \hline
 \end{tabular}
 \caption{\small Complexity of \SIPs with symmetric social relationships. $f(k)$ can be an arbitrary function of $k$ that only depends on $k$.
All entries other than ``P'' imply NP-completeness.
 ``W[1]-C'' and ``W[2]-C'' mean W[1]-completeness and W[2]-completeness, respectively. 
 All results are original (including classical complexity results). }
 \label{SIP:tbl:summary_symmetric}
 \end{table*}

Recall the definition of ``symmetric social relationships'' from Definition~\ref{SIP:def:symmetric_social}.
Under symmetric social relationships, both $k$-IR-Invitation and $k$-Stable-Invitation admit efficient FPT algorithms when $\beta$ is bounded, as shown in Table~\ref{SIP:tbl:summary_symmetric}, although their complexity does not change when $\beta$ is unbounded (W[1]-complete and W[2]-complete, respectively).

When we compare results in Table~\ref{SIP:tbl:summary} and Table~\ref{SIP:tbl:summary_symmetric}, two interesting observations can be made.
First, $k$-IR-Invitations and $k$-Stable-Invitations have the same classical complexity even under symmetric social relationships. Second, both problems now admit efficient FPT algorithms for broader domains of inputs -- as long as $\beta$ is bounded.
Note that our classical complexity results are original (i.e., not implied by Theorem~\ref{SIP:thm:nphard}) because Lee and Shoham~\cite{LEE15AAAI} did not consider the special case of symmetric social relationships. 

\subsection{Symmetric $k$-IR-Invitations}

We first present classical complexity results for $k$-IR-Invitations under symmetric social relationships, followed by parameterized complexity results. 


\begin{theorem} \label{SIP:thm:symmetric_IR_p_npc}
	When agents have symmetric social relationships, 
	$k$-IR-Invitations can be solved in polynomial time if (i) $\beta = 0$, (ii) $\beta = 1$ and $\alpha \leq 1$, or (iii) $\beta = 2$ and $\alpha = 0$. Otherwise, the problem is NP-hard. 
\end{theorem}
\begin{proof}
	Let us consider case (ii) in the statement. 
	As before, without loss of generality assume that all agents accept the size $k$ (i.e., $k\in S_i$ for all $a_i\in N$). 
	
	We first construct an {\em enemy graph} in which nodes represent agents, and we create an edge between two nodes if their corresponding agents are enemies of each other. For every pair of friends, we merge their nodes in this graph into a meta-node of weight $2$ (if they are also enemies of each other, then we simply remove them from the graph); let us call the resulting graph a {\em friend graph}. 
	Now finding an IR invitation of size $k$ is equivalent to finding an independent set of total weight $k$ in the friend graph. Although finding an independent set (of an arbitrary size) is NP-hard, all nodes in the friend graph have at most two edges, and thus each connected component in the friend graph is either a path or a cycle. 
	A dynamic programming algorithm can solve this problem.
	For each connected component (which is either a path or a cycle), we can check for every integer $x$ between $0$ and $k$, inclusive, whether it is possible to choose exactly $k$ nodes (agents) from the component, while satisfying individual rationality (provided that we will choose $k-x$ agents from other components, thereby making the invitation's size equal to $k$). This check can be done trivially: If a path contains $y$ nodes in total, we can choose up to $\lceil y/2 \rceil$ agents from the component (which should be an independent set in the enemy graph) and if a cycle contains $z \geq 3$ nodes in total, we can choose up to $\lfloor z/2 \rfloor$ nodes. After this check for each component and each integer, we can solve the main problem using a knapsack-like algorithm to find an IR invitation of size $k$.

 	Case (i) can be solved in polytime as follows (again, assume $k \in S_i$ for every agent $a_i$). Because $\beta = 0$, agents only have friends. Again we construct a friendship graph in which nodes are agents and there is an edge between two nodes if they are friends of each other in \SIP. Now we find all connected components in this graph; everyone in the same component must all be invited or all be uninvited. This reduces to a knapsack problem where we seek a subset of components whose total weight (the number of nodes in them) is equal to $k$. 

	Lastly, Case (iii) can be solved in polytime as follows (again, assume $k \in S_i$ for every agent $a_i$).
	Since $\alpha = 0$, no agent has friends. If we construct an enemy graph in which nodes are agents and there is an edge between two nodes if the corresponding agents are enemies, then finding an IR invitation of size $k$ is equivalent to finding an independent set of size $k$ in the enemy graph we constructed. Furthermore, each node in this graph has at most two edges (because $\beta = 2$), and therefore every connected component in this graph is either a path or a cycle. Again, we can use a dynamic programming algorithm (similar to the one we used for Case (i) above) to solve this problem in polytime.

		
	Let us now prove that the problem is NP-hard if none of the three conditions in the statement holds. 
	It is known that the Independent Set problem is NP-hard even if every node has degree at most 3~\cite{Garey_Max_Is_Cubic}. 
	Given an instance of this problem, we can create an instance of $k$-IR-Invitations as follows. 
	For each node, we create an agent $a_i$ with $S_i =\{k\}$ (agent only approves size $k$). 
	If there is an edge between two nodes, we make their corresponding agents enemies of each other. 
	The resulting instance is a valid instance (with symmetric social relationships) of $k$-IR-Invitations with $\alpha = 0$ and $\beta = 3$ (because each node in the original instance as at most three neighbors). 
	This shows NP-hardness of $k$-IR-Invitations with symmetric social relationships when $\alpha = 0$ and $\beta \geq 3$.	
	
	We can modify our reduction to show that the problem is NP-hard when $\alpha = 2$ and $\beta = 1$.
	First, given an instance of the Independent Set problem with max-degree 3, we create three agents for each vertex and make the three agents friends with one another; these three agents together represent a vertex in the original instance.
	For each edge in the original instance, pick one agent from each component representing the either end-point of the edge, and make them enemies of each other; because each node has at most three edges in the original instance, we can manage to keep each agent's enemy set to contain at most one agent. Lastly, we set approval sets of agents such that everyone approves of size $k$. The resulting instance is a valid instance of \SIPs with symmetric social relationships with $\alpha = 2$ and $\beta = 1$. 
	
	Lastly, we need a similar modification to our reduction for the case when $\alpha = 1$ and $\beta = 2$. 
	First, given an instance of the Independent Set problem with max-degree 3, we create two agents for each vertex and make the two agents friends with each other; these two agents together represent a vertex in the original instance.
	For each edge in the original instance, pick one agent from each component representing the either end-point of the edge, and make them enemies of each other; because each node has at most three edges in the original instance, we can manage to keep each agent's enemy set to contain at most two agents (and each component can have at most four edges). Lastly, we set approval sets of agents such that everyone approves of size $k$. The resulting instance is a valid instance of \SIPs with symmetric social relationships with $\alpha = 1$ and $\beta = 2$. 
 	
	Note that NP-hardness for $\alpha = a$ and $\beta = b$ implies NP-hardness for $\alpha \geq a$ and $\beta \geq b$.
	Hence, our proofs provide a complete analysis as stated in the theorem.
	
\end{proof}


\begin{theorem} \label{SIP:thm:symmetric_IR_FPT}
	When agents have symmetric social relationships, 
	$k$-IR-Invitations is in FPT if $\beta \leq f(k)$ where $f(k)$ can be an arbitrary function of $k$. 
\end{theorem}
\begin{proof}
	As before, without loss of generality, assume $k\in S_i$ for all $a_i\in N$. 
	We first create a {\em friend graph} in which nodes represent agents, and we create an edge between two nodes if their corresponding agents are friends. Clearly, subsets of nodes in this graph and invitations have one-to-one correspondence.
	In the friend graph, it is clear that all or none agents in each component should be chosen to form an IR invitation. 
	Thus, if any connected component contains two nodes whose corresponding agents are enemies of each other, then we can safely remove the component from the graph (as it cannot be included in any IR invitation).
	Likewise, if any component contains more than $k$ agents, we can remove the component as well. 
	
	We then create an {\em enemy graph} in which nodes represent connected components in the friend graph. Each node in the enemy graph has a weight that is equal to the size of the component it represents, and we create an edge between two nodes if their corresponding components contain a pair of enemies (one agent in each component). Because each agent has at most $\beta$ enemies, each node in the enemy graph has at most $k\cdot \beta$ edges. 
	Notice that an independent set in the enemy graph represents an IR invitation in the original instance. 
		
	Similarly to the FPT algorithm given in proof of Theorem~\ref{SIP:thm:IR_invitation_FPT}, we use Color Coding to color each node in the enemy graph as $\{0,1\}$ with equal probability.
	If there is any edge in the enemy graph whose both end-points (components) are of color 1, then we re-color both of them as 0. We repeat this process until no such pair exists (which can be done in linear time by scanning through the edges). 
	After this step, it is clear that all nodes of color $1$ form an independent set; we can easily determine if a subset of nodes whose weight is $k$ exists, using a knapsack-like algorithm. 
	
	Provided that an IR invitation of size $k$ exists, this algorithm's probability of success is at least $(1/2^k) \cdot (1/2^{k\beta}) \geq 1/2^{k(1+f(k))}$. For any fixed IR invitation $I^*$ of size $k$, 
	we color all agents in $I^*$ as color 1 with probability $1/2^k$, and with probability at least $1/2^{k \beta}$ we color the union of enemies of all agents in $I^*$ as color $0$. Regardless of coloring of all other agents, this coloring will ensure that all agents in $I^*$ remain to be of color $1$ in the enemy graph, and thus our algorithm can find $I^*$ (or some other solution). 
	
	The overall runtime of our algorithm is $O(f(k) n)$ as all sub-routines can be implemented in linear time in size of each graph and each graph contains at most $O(n)$ nodes and $O(f(k)n)$ edges.
	We can repeat this randomized algorithm $2^{k(1+f(k))}\ln n$ times to increase the probability of success to $1-1/n$ (with overall runtime $2^{k(1+f(k))}(f(k) n \ln n)$).
	This algorithm can also be de-randomized using a family of $k$-perfect hash functions~\cite{ColorCoding}. 
\end{proof}

Lastly we show that $k$-IR-Invitations remains to be W[1]-complete, even under symmetric social relationships, when $\beta$ is not bounded. Proof of W[1]-hardness is similar to that of Theorem~\ref{SIP:thm:IR_invitation_large_beta}, and completeness follows from Theorem~\ref{SIP:thm:IR_invitation_W1}. We omit proof of Theorem~\ref{SIP:thm:symmetric_IR_W1C}.
\begin{theorem} \label{SIP:thm:symmetric_IR_W1C}
	When agents have symmetric social relationships, 
	$k$-IR-Invitations is W[1]-complete if $\beta$ is not bounded above by any function of $k$. 
\end{theorem}



\subsection{Symmetric $k$-Stable-Invitations}
Interestingly, complexity of $k$-Stable-Invitations and that of $k$-IR-Invitations are identical, except when $\beta$ is unbounded, if we assume symmetric social relationships.
This implies that the combinatoric complexity due to social relationships plays an important role in \SIP, and restrictions on social relationships (such as symmetry) can substantially reduce the complexity. 
Yet we emphasize that both polytime and FPT algorithms for $k$-Stable-Invitations are much more complicated than those for $k$-IR-Invitations, and much of its complexity is due to the additional requirement that uninvited agents must not be willing to attend.

We first present classical complexity results for $k$-Stable-Invitations under symmetric social relationships, followed by parameterized complexity results. 


\begin{theorem} \label{SIP:thm:symmetric_stable_p_npc}
	When agents have symmetric social relationships, 	
	$k$-Stable-Invitations can be solved in polynomial time if (i) $\beta = 0$, (ii) $\beta = 1$ and $\alpha \leq 1$, or (iii) $\beta = 2$ and $\alpha = 0$. Otherwise, the problem is NP-hard. 
\end{theorem}
\begin{proof}
	Let us first consider the case (i) when $\beta = 0$.
	We construct a friend graph as before, and find connected components in this graph. 
	Any stable invitation must contain all or none of nodes in each connected component.
	For each connected component, we check two things: Whether a stable invitation can contain all of nodes in the component and whether it can contain none of nodes in it. 
	To check the first, we simply check if the component is of size $k$ or less and if everyone in the component approves size $k$. 
	To check the second, we check if the component contains two or more nodes (then we can leave them out) or if it is a singleton component but the only agent in it does not approve size $k$ (then we can leave the agent out). All of these checks can be done in linear time.
	Now we can use a dynamic programming algorithm to determine whether a subset of connected components that contains $k$ nodes over all such that every component (whether selected or not) does not violate the stability conditions (which can be easily checked by the two conditions we processed earlier).
	
	Let us now consider case (ii) where $\alpha \leq 1$ and $\beta = 1$.
	We first construct a friend graph, and merge any connected component into a meta-node with weight 2.
	The resulting graph would only have nodes but no edges, and each node is either of weight 1 or 2.
	Now we construct an enemy graph on top of this by creating an edge between nodes if their corresponding agents are enemies of each other; if we create self-loops, then it means two agents are both friends and enemies at the same time, and we just remove them from our graph (and input instance) with no harm.
	Now, after all edges are created, each node of weight 1 has at most one edge and each node of weight 2 has at most two edges. This implies that all connected components in this graph are either a path or a cycle.
	We can use the same algorithm for case (iii) below to solve this problem. 

	Finally let us consider case (iii) where $\alpha = 0$ and $\beta = 2$.
	Let us construct an enemy graph by creating nodes for agents and an edge between nodes if the agents are enemies of each other. Each node can have at most two edges because $\beta = 2$.
	Therefore, every connected component in the enemy graph is either a path or a cycle.
	For each connected component and every integer $x$ between $0$ and $k$, we check if it is possible to choose exactly $x$ nodes from the component such that inviting their corresponding agents and not inviting other agents (in the same component) do not violate stability conditions. This is similar to finding an independent set on a path or a cycle, but with extra conditions: the nodes not being chosen must still satisfy the stability requirements (by not approving size $k+1$ or by having one of its neighbors included in the set). We omit the details, but mention that this can be solved by a dynamic programming algorithm in polytime. After this step, we can solve the main problem using a knapsack algorithm in a straightforward manner. 
	
	Our reductions for $k$-IR-Invitations in proof of Theorem~\ref{SIP:thm:symmetric_IR_p_npc} show NP-hardness for $k$-Stable-Invitations as well, because agents only approve invitations of size $k$ in our reduction; it ensures that any uninvited agent would be unwilling to attend due to the size of an invitation.
	
\end{proof}



\begin{theorem} \label{SIP:thm:symmetric_stable_FPT}
	When agents have symmetric social relationships, $k$-Stable-Invitations is in FPT if $\beta \leq f(k)$ where $f(k)$ can be an arbitrary function of $k$. 
\end{theorem}
\begin{proof}
	The main is similar to that of our proof of Theorem~\ref{SIP:thm:symmetric_IR_FPT}, but details entail more complicated processes due to stability conditions on uninvited agents.

	We first create a {\em friend graph} in which nodes represent agents, and we create an edge between two nodes if they are friends of each other. 
	Any stable invitation must contain all or none of agents in the same connected component; if a connected component contains more than $k$ agents or it contains enemies within itself, then we can safely remove the components (or agents in them) from input instance. 
	Also, if a connected component of size at least $2$ contains an agent who does not approve size $k$, then we remove the entire connected component; if it is just one agent who does not approve size $k$, then we remove it only if it does not approve size $k+1$ as well (this is because of stability conditions). 
	After the removal process, we create an {\em enemy graph} by treating each connected component as a weighted node whose weight is equal to the size of the component, and creating an edge between nodes if they contain enemies (one in each).
	
	Again, we use color coding approach by coloring nodes using two colors $\{0,1\}$ uniformly and independently at random. 
	If two adjacent nodes in the enemy graph are both colored as 1, then we re-color both of them to 0. 
	We repeat the re-coloring step until no such nodes remain; at this point, all nodes of color 1 form an independent set, and any subset of them form an IR invitation.
	We will try to find a subset of nodes of color $1$ whose weight is equal to $k$ that forms a stable invitation. We can disregard any node of color 0 and weight greater than 1, because the agents contained in those nodes would not block stability (because we only consider single-agent deviation).
	On the other hand, singleton nodes of color $0$ may block an invitation when excluded, if those node approve size $k+1$ and no enemy of them are invited. 
	To avoid this, we are going to choose at least one enemy (of color $1$) of each singleton node of color $0$ who approves size $k+1$ in brute-force manner; the search space is bounded because we can only choose up to $k$ agents and each agent has at most $f(k)$ enemies (i.e., the search space is $O((f(k))^k)$). After we pre-select a subset of agents of color $1$ in this manner, we no longer need to worry about stability condition being violated by any agent of color $0$. Next, we check if there is any singleton node of color $1$ who approves size $k+1$ and is not pre-selected in the previous step; those nodes must also be included so as not to violate stability condition. Suppose that we have so far selected $x$ agents in this manner; if $x > k$, then our algorithm will (possibly incorrectly) report that no stable invitation of size $k$ exists. Otherwise, among the remaining nodes of color $1$, we will check if an independent set of weight $k - x$ exists (via a knapsack algorithm), to solve the main problem.

		Overall, this randomized algorithm runs in FPT time ($O((f(k))^k \cdot (f(k)n))$), and its probability of success is at least $(1/2^k)\cdot (1/2^{k\beta}) \geq 1/2^{k(1+f(k))}$ (similar to the algorithm shown in Theorem~\ref{SIP:thm:symmetric_IR_FPT}).
		
\end{proof}



\section{Discussion and Future Work} \label{SIP:sec:discussion}
In this work we investigated the parameterized complexity of the Stable Invitations Problem (\SIP) for two different solution concepts -- individual rationality and (Nash) stability, when the size of a solution is parameterized.
We considered restrictions on inputs by limiting the number of friends and enemies each agent can have, and also studied the special case in which all agents have symmetric social relationships.
Despite the fact that the majority of the problems we consider in this work are NP-hard, we showed that many special cases of the problem admit efficient FPT algorithms.
Our results indicate that the computational complexity of \SIPs varies when its input is restricted or the solution concept changes, which is not distinguishable under the classic complexity.
Our work leaves a few interesting open problems for future work. 
Lee and Shoham~\cite{LEE15AAAI} considered another solution concept in which agents who are not invited are not envious of those who are invited (motivated by `envy-freeness'). It would be interesting to analyze the parameterized complexity of finding an envy-free invitation of size $k$, and compare the results with what we have in this work. In addition, analyzing the parameterized complexity of the Group Activity Selection Problem~\cite{GASP12WINE} is another interesting direction for future work. 


